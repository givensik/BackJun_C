# Chapter 5 우선순위 큐

---

# 우선순위 큐 ADT

- 임의의 데이터 항목이 삽입되며, 일정한 순서에 의해 삭제되는 데이터구조
- 저장되는 각 데이터 항목은 (키, 원소) 쌍으로 정의된다.

(키, 원소) ⇒ [ 우선순위 큐 ] ⇒ 원소

# 우선순위 큐 응용

- 경매시장
    
    어떤 상품에 대한 낙찰 → 가장 최근에 응찰한 응찰자가 아닌 최고가를 쓴 응찰자가 낙찰됨
    
- 정렬에 이용
    
    정렬 : 데이터원소들을 일정한 키 순서에 의해 다시 배치하는 것
    
    정렬과정 → 데이터원소들을 임시 보관하는 저장소를 이용하는 경우가 많음(우선순위 큐를 저장소로 이용할 수 있음)
    

# 우선순위 큐 ADT 메쏘드

### 주요 메쏘드

- insertItem(k,e) : 키 k인 원소e를 큐에 삽입
- element removeMin() : 큐로부터 최소 키를 가진 원소를 삭제하여 반환

### 일반 메쏘드

- integer size(): 큐의 항목수를 반환
- boolean isEmpty(): 큐가 비어 있는지 여부를 반환

### 접근 메쏘드

- element minElement(): 큐에서 최소 키를 가진 원소를 반환
- element minKey() : 큐에서 최소 키를 반환

### 예외

- emptyQueueException(): 비어 있는 큐에 대해 삭제나 원소 접근을 시도할 경우 발령
- fullQueueException(): 만원 큐에 대해 삽입을 시도할 경우

## 우선순위 큐를 이용한 정렬

알고리즘 PQ-Sort

- 우선순위 큐의 상세 구현과 상관 없이, 우선순위 큐를 이용한 일반적인 정렬
- 원리
    1. 우선순위 큐 P를 초기화 → 입력 리스트 L의 원소들을 차례대로 삭제하면서 P에 삽입
    2. P로 부터 최소 키를 가진 원소부터 차례대로 삭제하며 L에 삽입
- 단계별 실행시간 → 우선 순위 큐에 따라서 다르다.

### 무순 리스트로 구현하는 경우

- 우선순위 큐의 항목들을 리스트에 임의 순서로 저장
- 성능 : 메쏘드 insertItem이 O(1) 시간에 수행됨, but removeMin, minKey, minElement 등 작업은 O(n) 시간이 걸림

### 순서리스트로 구현

- 우선순위 큐의 항목들을 리스트에 키 순서로 저장
- 성능 : 메쏘드 insertItem은 O(n) 시간에 수행되지만 removeMin, minKey, minElement 등 작업은 O(1) 시간에 수행함.

## 선택 정렬

- PQ-Sort의 일종, 우선순위 큐가 **무순리스트**로 구현됨
- 실행시간
    
    insertItem시 O(n) 시간 소요, removeMin 작업시 원소들을 우선순위 큐로부터 키 순서로 삭제 (n + (n-1) + (n-2) + .. + 2 + 1에 비례하는 시간을 소요) → O($n^2$) 시간이 수행됨
    

## 삽입 정렬

- PQ-Sort의 일종, 우선순위 큐가 **순서리스트**로 구현됨
- 실행시간
    
    insertItem n회 작업 사용, removeMin 작업 사용해서 우선순위 큐로부터 정렬 순서 삭제하는 데 O(n) 시간을 소요 → O($n^2$) 시간이 수행됨
    

삽입 정렬과 선택정렬은 동일한 PQ-Sort 알고리즘을 사용하지만,  다른점은 알고리즘이 사용하는 주요 데이터구조인 우선순위 큐 P가 어떻게 구현되었는지다.

# 제자리 정렬

- 앞서 말했던 선택정렬 → 원래 제공된 메모리 n 이외에 n의 추가적인 메모리를 사용(새로운 리스트를 만들고 그거를 이용해서 정렬함.
- 이를 제자리 정렬로 구현 → 원래 제공된 메모리 n + 상수 메모리를 사용
- 같은 실행시간 수행해도 **메모리 사용량이 줄음**

## 제자리 선택 정렬

### 선택 정렬을 제자리에서 수행 : 입력 리스트의 일부를 우선순위 큐로

- 리스트의 앞 부분을 정렬 상태로 유지
- 리스트에서 원소를 삭제하는 대신 원소들의 자리를 맞바꿈

| 5 | 3 | 4  | 2 | 1 |
| --- | --- | --- | --- | --- |

이런식으로 되어있다고 치고 작은거부터 차례대로 정렬을 해야한다고 가정을 하고, 리스트의 앞부분이 오름차순 정렬되어야 한다하자.(정렬된 리스트는 회색으로 채움) 제자리 선택 정렬을 하기 위해서 위의 리스트를 우선순위 큐라고 가정한다. 그리고 가장 최소인 원소인 1을 가장 앞의 원소인 5와 바꾼다.

| 1 | 3 | 4 | 2 | 5 |
| --- | --- | --- | --- | --- |

이제 밑줄친 애들이 우선순위 큐인애들이다. 그럼 이번에도 우선순위 큐에서 가장 작은 원소인 2를 가장 앞의 원소인 3과 바꾼다.

| 1 | 2 | 4 | 3 | 5 |
| --- | --- | --- | --- | --- |

이러한 방식을 계속 반복하면

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |

이렇게 정렬이 가능하다.

## 제자리 삽입 정렬

### 삽입 정렬을 제자리에서 수행 : 입력 리스트의 일부가 우선순위 큐가 된다.

- 리스트의 앞 부분을 정렬 상태로 유지
- 리스트에서 원소를 삭제하는 대신 원소들의 자리를 맞바꾼다.

이번에도 이런 리스트가 있다고 가정하자. 그리고 앞부분에서 오름차순 정렬을 한다고하면

| 5 | 4 | 3  | 2 | 1 |
| --- | --- | --- | --- | --- |

가장 먼저 5가 큐에서 나올거다.

| 5 | 4 | 3  | 2 | 1 |
| --- | --- | --- | --- | --- |

이렇게 되고, 다음에는

| 5 | 4 | 3  | 2 | 1 |
| --- | --- | --- | --- | --- |

이렇게 큐에서 다음에 나올 아이가 나오고, 정렬될 리스트 애들끼리 서로 자리를 바꾸면서 정렬을 한다.

| 4 | 5 | 3  | 2 | 1 |
| --- | --- | --- | --- | --- |

이렇게 돼고, 다음 단계를 실행하면

| 4 | 5 | 3  | 2 | 1 |
| --- | --- | --- | --- | --- |

| 4 | 3 | 5  | 2 | 1 |
| --- | --- | --- | --- | --- |

| 3 | 4 | 5  | 2 | 1 |
| --- | --- | --- | --- | --- |

이렇게 정렬이 되고 이러한 방법을 계속 진행하면

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |

이런식으로 정렬되는거 같다.

# 선택 정렬과 삽입 정렬 비교

## 공통점

- 전체적으로 O($n^2$) 시간에 수행된다. 중첩 반복문(내부 반복문 : 선형탐색 O(n) 시간에 수행, 외부 반복문 O(n)개의 정렬 단계로 구성)
- 기억공간 소요량 → 제자리 버전 O(1) 공간 소요
- 두 알고리즘 모두 구현이 단순하다는 장점이 있음 → 입력 크기 n이 작은 경우에 유용

## 차이점

- 초기 입력 리스트가 거의 정렬된 경우 → 제자리 삽입 정렬이 제자리 선택 정렬보다 빠름
- 데이터 원소끼리 교환 작업(메쏘드 swapElements)에 시간이 많이 걸리는 경우 제자리 선택 정렬이 더 빠름.

| 우선 순위 큐 | insertItem | removeMin | minKey,minElement | 정렬 방식 |
| --- | --- | --- | --- | --- |
| 무순 리스트 | O(1) | O(n) | O(n) | 선택 정렬 |
| 순서 리스트 | O(n) | O(1) | O(1) | 삽입 정렬 |