# Chapter 6 Heap and Heap Sort

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 4 →7 | 7→4 | 3 | 5 | 9 | 1 |

# 힙

우선순위 큐 ADT구현 하는 또 다른 방식 → 힙

### 힙이란?

내부 노드에 키를 저장하면서 다음 두 가지 속성을 만족하는 이진트리

- 힙 순서(heap-order)
    
    루트를 제외한 모든 내부노드 v에 대해 key(v) ≥ key(parent(v))를 만족
    
    = 모든 부모-자식 관계에서 부모노드의 키가 자식노드의 키보다 작거나 같도록 구성됨
    
    외부 노드에는 데이터 원소를 저장하지 않음
    
- 완전이진트리(complete binary treee)로 구성되어야함
    
    힙의 높이를 h라 가정하면
    
    - i = 0, … i = h-1 에 대해 깊이 i인 노드가 $2^i$개가 존재
    - 깊이 h-1에서 내부 노드들은 외부 노드들의 왼쪽에 존재

힙의 접근점

- 마지막 노드 → 힙의 높이를 h라할 때 깊이 h-1의 가장 오른쪽 내부 노드

|  |  | 2 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 |  |
| 9 | 7 |  |  |  |
|  |  |  |  |  |

이런 구조로 되어있다하면 7이 마지막 노드다.

## 힙의 높이

- 정리 : n개의 키를 저장한 힙의 높이는 O(logn)
- 증명 : 완전 이진트리의 성질을 이용

n개의 키를 저장한 힙의 높이를 h라하면 n ≥ 1 + 2 + 2^1 + … +2^(h-2) +1(깊이 h-1에는 적어도 하나 존재) 이므로 n≥2^(h-1) 이므로 h≤logn+1 이다.

# 힙을 이용한 우선순위 큐 구현

### 우선순위 큐 ADT 역할을 하기 위한 조건

- 데이터 항목의 삽입과 삭제가 자유로운 저장소
    - 힙을 구성하는 이진트리 각 내부노드에 (키, 원소) 쌍의 데이터 항목을 저장
    - 힙에 관한 작업의 편의상 외부노드에는 데이터 항목을 저장하지 않는 것으로 함
    - 마지막 노드의 위치를 변수로 관리
- 삭제의 경우 최소 키를 가진 항목을 삭제

|  |  | (2,지은) |  |  |
| --- | --- | --- | --- | --- |
|  | (5, 유진) |  | (6,동아) |  |
| (9,민아) | (7, 서림) |  | (8, 서희) |  |
|  |  |  |  |  |

| 2 | 5 | 6 | 9 | 7 | 8 |
| --- | --- | --- | --- | --- | --- |

배열로 키만 표현하면 이렇게 된다.

## 힙에 삽입

insertItem 삽입 메쏘드

### 삽입 알고리즘

1. 삽입 노드 z, 즉 새로운 마지막 노드를 찾는다.
2. k를 z에 저장한 후, z를 내부 노드로 확장한다.
3. 힙순서 속성을 복구한다.

```
Alg insertItem(k)
	input key k, node last
	output none
1. advanceLast() // 마지막 노드를 오른쪽으로 이동
2. z <- last
3. Set node z to k
4. expandExternal(z) //추가되면 외부노드가 되는데 이를 내부노드로 바꾸는 과정
5. upHeap(z)
6. return
```

```
Alg upHeap(v)
	input node v, node last
	output none
1. if (isRoot(v))
		return
2. if (key(v) >= key(parent(v)))
		return
3. swapElements(v, parent(v))
4. upHeap(parent(v))
```

이거는 재귀적으로 한거

### 예시

|  |  | 2 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 |  |
| 9 | 7 |  | z |  |

마지막 노드보다 오른쪽의 노드를 삽입 위치 z로 설정한다.

|  |  | 2 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 |  |
| 9 | 7 |  | 1 |  |

삽입 노드 z에 새 키 k를 삽입한 후 z을 내부노드로 확장한다.(이때 힙순서 속성이 위배될 수 있음)

그래서 아래에서 upheap알고리즘을 실행한다.

|  |  | 2 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 → 1 |  |
| 9 | 7 |  | 1 → 6 |  |

알고리즘 upheap ⇒ 삽입노드로부터 상향경로를 따라가며 키k를 교환함으로써 힙순서 속성을 복구

|  |  | 2 → 1 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 1 → 2 |  |
| 9 | 7 |  | 6 |  |
- upheap은 루트 또는 부모의 키가 k보다 작거나 같은 노드에 도달하면 정지하고, 힙의 높이는 O(log n) 이므로, upheap은 O(log n) 시간에 수행함.

### 힙이 연결트리로 구현된 경우

→ 알고리즘 insertItem이 호출하는 expandExternal(z)는 트리 노드의 삽입을 위한 구체적인 작업(노드 z의 왼쪽과 오른쪽에 각각 동적메모리부터 할당받은 외부노드 자식을 추가함으로써 노드 z를 내부노드로 확장)

내부노드로 확장한다는거는 빈 자식노드 2개를 만들어둔다는 뜻인거같다.

```
Alg expandExternal(z) {Linked}일때
	input external node z
	output none

1. l <- getnode() //새로 들어온 노드의 왼쪽, 오른쪽 노드를 추가
2. r <- getnode()
3. l.left <= null
4. l.right <= null
5. l.parent <- z
6. r.left <= null
7. r.right <= null
8. r.parent <- z
9. z.reft <- l
10. z.right <- r
11. return
```

## 힙으로부터 삭제

removeMin 삭제 메쏘드

### 삭제 알고리즘

1. 루트 키를 마지막 노드 w의 키로 대체한다
2. w와 그의 자식들을 잎으로 축소한다.
3. 힙순서 속성을 복구한다.

```
Alg removeMin()
	input node last
	ouput key

1. k <- key(root())
2. w <- last
3. Set root to key(w)
4. retreatLast() // 루트로 옮긴 원소의 원래자리를 치우고 마지막 원소를 왼쪽으로 옮기기
5. z <- rightChild(w)
6. reduceExternal(z) // 내부노드였던 마지막 원소 노드를 없애는 과정
7. downHeap(root())
8. return k //지운 값 반환
```

```
Alg downHeap(v)
	input node v whose left and right subtrees are heaps
	output a heap with root v

1. if(isExternal(leftChild(v)) & isExternal(rightChild(v))) // 자식들이 모두 외부 노드일때 끝
			return
2. smaller <- leftChild(v) {internal node}일때
3. if(isInternal(rightChild(v)) //오른쪽은 내부노드가 아닐 수 있으니까
			if(key(rightChild(v)) < key(smaller))
					smaller <- rightChild(v)
4. if(key(v) <= key(smaller)) 
			return
5. swapElements(v,smaller)
6. downHeap(smaller)

```

예시

|  |  | 2 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 |  |
| 9 | 7 w (last node) |  |  |  |
|  |  | z |  |  |

루트에 저장된 키를 반환하기 위해 일시 저장, 가장 마지막 노드 w의 키를 루트에 복사하고 retreatLast를 호출해서 마지막 노드를 왼쪽으로 갱신 (이때 루트 키를 마지막 노드로 대체한 후에 힙순서 속성이 위배될 수 있다.) 이때 downheap을 실시한다.

|  |  | 7 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 |  | 6 |  |
| 9 (last node) | w |  |  |  |
|  |  |  |  |  |

downheap 알고리즘 ⇒ 루트로부터 하향경로를 따라가며 키 k를 교환함으로써 힙순서 속성을 복구

- 자식들 중 더 작은애랑 비교해서 더 작으면 서로 교환하고 아니면 교환 안함

|  |  | 7 → 5 |  |  |
| --- | --- | --- | --- | --- |
|  | 5 → 7 |  | 6 |  |
| 9 (last node) | w |  |  |  |
|  |  |  |  |  |

|  |  | 5 |  |  |
| --- | --- | --- | --- | --- |
|  | 7 |  | 6 |  |
| 9 (last node) | w |  |  |  |
|  |  |  |  |  |

- downheap은 키 k가 잎, 또는 자식의 키가 k보다 크거나 같은 노드에 도달하면 정지, 힙의 높이는 O(log n)이므로, downheap도 O(log n)시간에 수행한다.

### 힙이 연결트리로 구현된 경우

reduceExternal(z)은 트리 노드의 삭제를 위한 구체적인 작업을 수행한다.( 외부노드 z의 부모노드 w를 z의 형제노드 zs로 대체하여 결과적으로 z의 부모노드를 z와 함께 삭제한다.

- 노드 z의 형제 zs가 외부 노드인 경우

before

| 5 (g) |  |
| --- | --- |
| 7 (w) |  |
| zs | z |

after

| 5 (g) |  |
| --- | --- |
| zs |  |
|  |  |
- 노드 z의 형제 zs가 내부노드인 경우

before

| 5 (g) |  |
| --- | --- |
| 7 (w) |  |
| 8 (zs) | z |

after

| 5 (g) |  |
| --- | --- |
| 8 (zs) |  |
|  |  |

```
Alg reduceExternal(z) {linked}
	input external node z
	output the node replacing the parent node of the removed node z

1. w <- z.parent
2. zs <- sibling(z)
3. if(isRoot(w))
			root <- zs
			zs.parent <- null
	  else 
			g <- w.parent
			zs.parent <- g
			if (w = g.left)
					g.left <- zs
			else { w = g.right }
					g.right <- zs

4. putnode(z)  {deallocate node z}
5. putnode(w)  {deallocate node w}
6. return zs
```

## 마지막 노드 갱신

삽입과 삭제 모두 마지막 노드를 갱신할 필요가 있음

### 삽입

- 삽입 노드를 찾기 위해 현재의 마지막 노드에서 하나 오른쪽 노드를 찾는다.
- 만약 가장 오른쪽에 있는 노드인 경우 삽입 노드는 다음 레벨의 맨 왼쪽 노드를 찾아야함.
- 알고리즘 advancdeLast → O(log n)개의 노드를 순회하면서 삽입 노드를 찾음
    - 현재 노드가 오른쪽 자식인 동안, 부모노드로 이동
    - 현재 노드가 왼쪽 자식이면, 형제노드로 이동
    - 현재 노드가 내부노드인 동안, 왼쪽 자식으로 이동

### 삭제

- 위와 반대방향으로 수행

# 힙 구현과 성능

### 힙 구현

- 이진 트리방식으로 구현
    1. 연결 이진트리 : 연결 리스트로 구현
    2. 순차 힙 : 배열을 사용하여 구현
        
        크기 n의 배열을 사용하여 표현하면
        
        |  | 2 | 5 | 6 | 9 | 7 |
        | --- | --- | --- | --- | --- | --- |
        - 여기서 첨자 i에 존재하는 노드에 대해 왼쪽 자식은 첨자 2i, 오른쪽 자식은 2i+1, 부모는 i/2에 각각 존재
        - 배열 첨자 0 셀은 사용하지 않는다.
        - 외부 노드는 실제 데이터 항목을 저장하지 않으므로 배열 원소로 표현할 필요 없음.
        - 힙에 대한 삽입 : n+1 위치에 삽입
        - 삭제 : 첨자 n 위치에 삭제하는 것

### 연결힙과 순차힙 비교

- 점근적 성능 → 기억 공간 소요량이랑 대부분 작업에서 동일
- 마지막 노드를 갱신하는 작업에서 차이점이 생김
    - 순차힙 : 단순히 +- 연산을 통해서 마지막 노드를 쉽게 갱신
    - 연결힙 : 링크를 따라 새 마지막 노드 위치를 찾아야하므로 시간이 더 걸림

힙 구현에 따른 성능 비교

| 힙 구현 | size, isEmpty | insertItem, removeMin | minKey, minElement | advanceLast, retreatLast | 공간 소요 |
| --- | --- | --- | --- | --- | --- |
| 연결 | O(1) | O(log n) | O(1) | O(log n) | O(n) |
| 순차 | O(1) | O(log n) | O(1) | O(1) | O(n) |

## 힙 정렬

힙의 성능을 바탕으로 n개의 원소로 이루어진 리스트 → O(n log n) 시간에 정렬 가능

- insertItem, removeMin 모두 O(log n) 시간에 수행 + n개를 하나씩 수행하면 n log n이 된다.

### 알고리즘 heapSort

- 비어 있는 힙 초기화
- 입력 리스트의 원소들을 하나씩 삭제하여 힙에 삽입
- 맨 앞의 원소 삭제 → O(1)
- 삽입 → O(log n)

```
Alg heapSort(L)
	input list L
	output sorted list L

1. H <- empty heap
2. while (!L.isHeap())
			k <- L.removeFirst()
			H.insertItem(k)
3. while (!H.isEmpty())
			k <- H.removeMin()
			L.addLast(k)
4. return
```

개선점

- 제자리 힙 정렬 → heapSort 공간 사용을 줄일 수 있음
- 상향식 힙생성 → heapSort의 속도를 높힐 수 있음

# 제자리 힙 정렬

- 리스트가 배열로 주어진 경우에만 적용
- 리스트 L의 일부를 가상 힙으로 사용하여 외부 힙 사용을 피함
- 최대힙(max-heap)을 사용

### 제자리 힙 정렬 알고리즘 inPlaceHeapSort

```
Alg inPlaceHeapSort(A)
	input array A of n keys
	output sorted array A

1. buildHeap(A)
2. for i <- n downto 2
			A[1] <-> A[i]
			downHeap(1,i-1)
3.return
```

buildHeap

```
Alg buildHeap(A)
	input array A of n keys
	output heap A of size n

1. for i <- 1 to n
			insertItem(A[i])
2. return
```

downHeap

```
Alg downHeap(i,last)
	input index i of array A representing a maxheap of size last
	output none

1. left <- 2i
2. right <- 2i + 1
3. if(left > last) // 내부 노드인지 확인, 외부노드라면 끝내기
			return
4. greater <- left // 자식 노드 중 큰 애?
5. if(right <= last) 
			if(key(A[right]) > key(A[greater])) // 오른쪽 자식 노드보다 왼쪽 자식노드가 작을때 오른쪽을 greater로 지정
					greater <- right
6. if(key(A[i]) >= key(A[greater)) //i번째 노드(부모)의 키가 자식노드들 중 큰 애보다 크면 끝
			return
7. A[i] <-> A[greater] // 자식보다 작다?
8. downEHap(greater, last)
```

 

### inPlaceHeapSort의 수행 단계

리스트 L이 이렇게 되어있다고 하면

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 4 | 7 | 3 | 5 | 9 | 1 |

### 1기

- 비어 있는 힙에서 시작해서 힙과 리스트의 경계를 왼쪽에서 오른쪽으로 한 번에 한 칸씩 이동한다.
- 단계 i( i = 1 , … ,n )에서 첨자 i에 있는 원소를 힙에 추가함으로써 힙을 확장한다.
- 그냥 리스트를 하나하나씩 힙으로 만든다고 생각하면 될 듯

n=1

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7 | 4 | 3 | 5 | 9 | 1 |

n=2, 힙을 생성

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 4 →7 | 7→4 | 3 | 5 | 9 | 1 |

n=3

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7 | 4 | 3 | 5 | 9 | 1 |

n=4, 인덱스 2의 자식 4 보다 인 인덱스 4인 5가 더 크므로 교환

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7 | 4→5 | 3 | 5→4 | 9 | 1 |

n=5, 인덱스 1의 자식들인 3, 5의 힙 성질을 이용해서 정리

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7→9 | 5→7 | 3 | 4 | 9→5 | 1 |

n=6

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 9 | 7 | 3 | 4 | 5 | 1 |

### 2기

- 비어 있는 리스트에서 출발하여 힙과 리스트의 경계를 오른쪽에서 왼쪽으로 한 번에 한 칸씩 이동
- 힙이 max힙이니까 제일 큰 애를 마지막 노드랑 교환하면서 빼면 배열의 가장 오른쪽으로 가고 힙에서 빠지는거니까 정렬이 됨
- 1기에서 생성한 힙에서 가장 큰 아이부터 빼면됨

시작(가장 마지막 원소랑 인덱스 1이랑 교환, 그냥 힙에서 루트를 제거한거라고 생각하면 됨)

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 9→1 | 7 | 3 | 4 | 5 | 1→9 |

마지막 원소부터 다운 힙

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1→7 | 7→5 | 3 | 4 | 5→1 | 9 |

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7 | 5 | 3 | 4 | 1 | 9 |

최대 값 빼기

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 7→1 | 5 | 3 | 4 | 1→7 | 9 |

다운 힙

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1→5 | 5→4 | 3 | 4→1 | 7 | 9 |

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 5 | 4 | 3 | 1 | 7 | 9 |

최대 값 빼기

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 5→1 | 4 | 3 | 1→5 | 7 | 9 |

다운 힙

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1 | 4 | 3 | 5 | 7 | 9 |

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 4 | 1 | 3 | 5 | 7 | 9 |

최대 값 빼기

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 4→3 | 1 | 3→4 | 5 | 7 | 9 |

다운 힙

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 3 | 1 | 4 | 5 | 7 | 9 |

최대 값 빼기

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 3→1 | 1→3 | 4 | 5 | 7 | 9 |

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1 | 3 | 4 | 5 | 7 | 9 |

끝

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1 | 3 | 4 | 5 | 7 | 9 |

# 상향식 힙생성

힙 정렬 1기에서 힙에 삽입할 때 O(n log n)시간에 힙 생성을 했음

근데 상향식 힙생성(bottom-up heap construction)방식을 사용하면 O(n)시간에 수행할 수 있음

- How?
    
    $2^i-1$개의 키를 가진 두 개의 힙을 2^(i+1) -1 개의 키를 가진 힙으로 합병할 수 있음
    

## 재귀적 상향식 힙생성

```
Alg buildHeap(L)
	input list L storing n keys
	output heap T storing the keys in L

1. T <- converToCompleteBinaryTree(L) // 입력 리스트 L을 완전 이진트리 T로 전환
2. rBuildHeap(T.root())
3. return T

Alg rBuildHeap(v)
	input node v
	output a heap with root v

1. if(isInternal(v))
			rBuildHeap(leftChild(v))
			rBuildHeap(rightChild(v))
			downHeap(v)
2. return

```

1. 입력 리스트 L을 완전이진트리 T로 전환
    1. 배열인 경우 → 첫 번째 셀을 비운 배열에 복사
    2. 연결리스트인 경우 → 추가적인 알고리즘 필요
2. rBuildHeap으로 재귀적 상향식 힙생성 수행
    
    rBuildHeap
    
    - 주어진 내부노드 v의 좌우 부트리에 대해 rBuildHeap 재귀 호출 → 반환된 힙 T1, T2
    - 반환된 부트리 T1, T2고, 루트가 v인 이진트리를 T로 만듬
    - T의 루트에서 downHeap 수행해서 T의 힙순서 속성을 복구

재귀호출이 힙인 부트리를 반환하는 방식 → 상향식(bottom-up)이라 불림(외부노드부터 시작해서 각 재귀호출이 반환되면서 트리 위쪽을 향해 진행하기 때문) → 이러한 과정을 힙화한다(heapify) 또는 힙화(heapification)을 수행한다고 말하기도 함.

## 비재귀식 상향식 힙생성

- 정렬되어야 할 리스트가 배열로 주어진 경우에만 적용 가능
- 내부노드를 왼쪽 자식으로 가지는 가장 깊은 내부노드 가운데 가장 오른쪽 노드에서 힙생성을 시작 → 루트를 향하는 후진방향으로 반복 수행
- 시작 노드 → n/2 번째 노드이다.

```
Alg buildHeap(A)
	input array A of n keys
	output heap A of size n

1. for i <- [n/2] downto 1
			downHeap(i,n)
2. return
```

## 상향식 힙생성의 성능

- 속도 성능
    
    알고리즘 downHeap의 최악의 경우, 방문하는 전체 노드 수는 O(n)(재귀든 뷔재귀든 상관없이 동일)이다.
    
    근데 힙생성은 어짜피 힙 정렬의 1기 작업이고, 힙 정렬 2기의 최악 실행시에도 여전히 O(log n)이다. 
    
    그래서 상향식 힙생성은 힙 정렬 전체의 점근적 속도를 향상하지 않지만, 상향식 힙생성은 n회의 연속적인 삽입보다 빠르므로 적어도 힙 정렬 1기의 속도를 향상시킴