# Chapter 7 Merge Sort

# 분할 통치법

### 분할통치법이란?

- 알고리즘이 원래 주어진 문제를 직접 해결하지 않는 대신 문제를 몇 개의 부문제로 분할하고 각 부문제의 해결을 알고리즘 자신에게 재귀적으로 위임
- 재귀의 마지막에 알고리즘이 직접 해결 가능한 크기의 부문제가 되면 문제를 더 이상 분할 위임하지 않고 직접 해결한 결과를 윗선의 호출 알고리즘에게 반환하는 방식의 문제해결 방식을 분할통치법이라고 한다.

### 분할통치법에 의한 알고리즘 해결절차

1. 분할(divide) : 입력 데이터 L을 둘 이상의 분리된 부분집합 L1, L2, … 으로 나눈다.
2. 재귀(recur) : L1, L2, … 각각에 대한 부문제를 재귀적으로 해결한다.
3. 통치(conquer) : 부문제들에 대한 해결을 합쳐 L의 해결을 구한다.

# 합병 정렬

### 합병 정렬(merge sort)

- 분할통치법에 기초한 정렬 알고리즘
- 힙 정렬처럼 비교에 기초한 정렬, O(nlog n)시간에 수행
    - 비교에 기초한 정렬 : 두 개의 키의 크기를 반복적으로 비교한 결과에 따라 정렬이 진행됨
- 힙 정렬과 다르게 외부의 우선순위 큐를 사용하지 않고, 데이터를 순차적(sequentail)방식으로 접근
    - 순차적 접근 : 정렬되어야 할 데이터원소들을 접근할 때 기억장소에 원소들이 저장된 물리적 순서를 그대로 따라감 → 순차적인 저장매체(디스크, 자기 테이프)에 존재하며 주기억장치에 일시에 탑재가 불가능한 초대규모의 데이터에 대한 정렬을 위해서 합병 정렬을 적용하는 것이 전체 수행시간 면에서 유리함
- 합병 정렬 알고리즘 단계
    1. 분할(divide) : 무순리스트 L을 각각 n/2개의 원소를 가진 두 개의 부리스트(sublist)L1과 L2로 분할
    2. 재귀(recur) : L1과 L2를 각각 재귀적으로 정렬
    3. 통치(conquer) : L1과 L2를 단일 순서리스트로 합병
    
    ```
    Alg mergeSort(L)
    	input list L with n elements
    	output sorted list L
    
    1. if (L.size() > 1)
    			L1, L2 <- partition(L,n/2)
    			mergeSort(L1)
    			mergeSort(L2)
    			L <- merge(L1,L2)
    2. return
    ```
    

## 합병

### 알고리즘 merge

- 재귀호출로 반환된 두 개의 정렬된 부리스트 L1과 L2를 각각의 원소들의 합을 포함하는 순서리스트 L로 합병하는 과정, L1과 L2는 각각 n/2개의 원소를 가짐
- L1과 L2를 합병하는데 O(n) 시간과 O(n) 공간을 소요

```
Alg merge(L1, L2)
	input sorted list L1, and L2 with n/2 elements each
	output sorted list of L1 U L2

1. L <- empty list
2. while (!L1.isEmpty() & !L2.isEmpty())
				if(L1.get(1)<=L2.get(1))
						L.addLast(L1.removeFirst())
				else
						L.addLast(L2.removeFirst())
3. while(!L1.isEmpty())
				L.addLast(L1.removeFirst())
4. while(!L2.isEmpty())
				L.addLast(L2.removeFirst())
5. return L
```

| L1 | 1 | 2 | 6 |  |
| --- | --- | --- | --- | --- |
| L2 | 3 | 4 | 5 | 7 |
| L |  |  |  |  |

| L1 | 2 | 6 |  |  |
| --- | --- | --- | --- | --- |
| L2 | 3 | 4 | 5 | 7 |
| L | 1 |  |  |  |

| L1 | 6 |  |  |  |
| --- | --- | --- | --- | --- |
| L2 | 3 | 4 | 5 | 7 |
| L | 1 | 2 |  |  |

| L1 | 6 |  |  |  |
| --- | --- | --- | --- | --- |
| L2 | 3 | 4 | 5 | 7 |
| L | 1 | 2 | 3 |  |

| L1 | 6 |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| L2 | 5 | 7 |  |  |  |
| L | 1 | 2 | 3 | 4 |  |

| L1 | 6 |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| L2 | 7 |  |  |  |  |
| L | 1 | 2 | 3 | 4 | 5 |

| L1 |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
| L2 | 7 |  |  |  |  |  |  |
| L | 1 | 2 | 3 | 4 | 5 | 6 |  |

| L1 |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
| L2 |  |  |  |  |  |  |  |
| L | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

## 합병 정렬 트리

- 알고리즘 mergeSort의 실행과정 → 이진트리 형태로 보일 수 있음 → 이런 이진트리를 합병 정렬 트리(merge-sort tree)라고 한다.

- 합병 정렬 트리로 나타낸 재귀 호출 과정과 순서

| 6 | 1 | 8 | 2 | 3 | 5 | 7 | 4 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| (6 | 1 | 8 | 2) | (3 | 5 | 7 | 4) |
| (6 | 1) | (8 | 2) | (3 | 5) | (7 | 4) |
| (6) | (1) | (8) | (2) | (3) | (5) | (7) | (4) |
- 합병 정렬 트리로 나타낸 반환 과정

| 1 | 2 | 3 | 4 | 5 | 5 | 7 | 8 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| (1 | 2 | 6 | 8) | (3 | 4 | 5 | 7) |
| (1 | 6) | (2 | 8) | (3 | 5) | (4 | 7) |
| (6) | (1) | (8) | (2) | (3) | (5) | (7) | (4) |

## 합병 정렬 분석

- 합병 정렬의 실행시간
    - 합병 정렬 트리의 높이 h = O(log n) ( 각 재귀 호출에서 리스트를 절반으로 나누므로 )
    - 레벨 i에서 $2^i$개의 크기 $n/2^i$의 리스트를 분할하고 2^(i+1)번의 재귀 호출을 하여 반환된 결과를 합병(배열인 경우 분할과 재귀호출 O(1) 시간 소요)
    - 레벨 i에서 합병에 걸리는 시간 : O(n) (크기가 n/2인 두 리스트를 합병하는데 걸리는 시간이 O(n)이므로)
    - 알고리즘 mergeSort의 전체 실행시간 = 합병에 걸리는 시간 O(n) $*$ 합병 정렬 트리의 높이 O(log n) = O(nlog n)
    
- n-키 리스트에 대한 알고리즘 mergeSort의 실행시간 T(n)의 점화식
    
    > T(n) = c (n<2)
    > 
    
    > T(n) = 2T(n/2) + O(n)
    > 
    
    → T(n) = O(nlog n)